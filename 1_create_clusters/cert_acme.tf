/*
Generate a private key for CA certificate
2048-bit RSA is the standard for TLS/SSL certificates
*/
resource "tls_private_key" "ca" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

/*
Let's Encrypt certificate configuration for AWS
Based on https://itnext.io/lets-encrypt-certs-with-terraform-f870def3ce6d
Uses AWS Route53 for DNS challenge validation
*/

# Get AWS Route53 hosted zone information
data "aws_route53_zone" "env_dns_zone" {
  name         = var.dns_zone_name_ext # Domain name (e.g., "example.com")
  private_zone = false                 # Public hosted zone
}

locals {
  # Domain name from Route53 hosted zone (removes trailing dot if present)
  domain = trimsuffix(data.aws_route53_zone.env_dns_zone.name, ".")

  # Sanitize region name for use in domain names (remove spaces, convert to lowercase)
  region_sanitized = lower(replace(var.region, " ", "-"))
}

/*
ACME provider configuration for Let's Encrypt
Choose between staging (testing) and production servers
*/
provider "acme" {
  # server_url = "https://acme-staging-v02.api.letsencrypt.org/directory" # Testing
  server_url = "https://acme-v02.api.letsencrypt.org/directory" # Production
  # server_url = "https://acme.zerossl.com/v2/DV90" # Alternative: ZeroSSL
}

/*
Generate private key for ACME account registration
This key is used to authenticate with Let's Encrypt
*/
resource "tls_private_key" "private_key" {
  algorithm = "RSA"
  rsa_bits  = 2048
}

/*
Register account with Let's Encrypt
Required before requesting certificates
*/
resource "acme_registration" "registration" {
  account_key_pem = tls_private_key.private_key.private_key_pem
  email_address   = var.owner_email # Contact email for certificate notifications
}

resource "random_string" "random_name" {
  length  = 4
  upper   = false
  lower   = true
  numeric = false
  special = false
}

/*
Request Let's Encrypt certificate using DNS challenge
DNS challenge is more secure and works behind firewalls
Uses AWS Route53 for automatic DNS record management
*/
resource "acme_certificate" "certificate" {
  account_key_pem = acme_registration.registration.account_key_pem
  common_name     = "vault-${local.region_sanitized}-${random_string.random_name.result}.${local.domain}"

  # Optional: Add wildcard certificate
  # subject_alternative_names = ["*.${local.domain}"]

  dns_challenge {
    provider = "route53" # AWS Route53 DNS provider

    config = {
      AWS_REGION = var.region # AWS region for Route53
      # Alternative: Use AWS_PROFILE = var.aws_profile for profile-based auth
    }
  }

  depends_on = [acme_registration.registration]
}

/*
Create DNS domain for Vault server
*/
resource "aws_route53_record" "vault" {
  zone_id = data.aws_route53_zone.env_dns_zone.zone_id
  name    = "vault-${local.region_sanitized}-${random_string.random_name.result}.${local.domain}"
  type    = "A"

  ttl = 300

  records = [
    aws_eip.vault_server_eip.public_ip
  ]

}

/*
Certificate data extraction from Let's Encrypt response
Provides fallback to empty strings if certificate generation fails
*/
locals {
  # Extract certificate components from ACME certificate resource
  vault_cert = try(acme_certificate.certificate.certificate_pem, "") # Public certificate
  vault_ca   = try(acme_certificate.certificate.issuer_pem, "")      # CA certificate chain
  vault_key  = try(acme_certificate.certificate.private_key_pem, "") # Private key
}

/*
TLS data formatted for Kubernetes secrets
Base64 encoding is handled by Kubernetes, so we provide raw PEM data
*/
locals {
  tls_data = {
    ca   = base64encode(local.vault_ca)   # CA certificate (base64 encoded)
    cert = base64encode(local.vault_cert) # Server certificate (base64 encoded)
    pk   = base64encode(local.vault_key)  # Private key (base64 encoded)
  }
}

/*
JSON-encoded secret data for use in Helm templates
Can be used directly in Kubernetes secret resources
*/
locals {
  secret = jsonencode(local.tls_data)
}

/*
AWS Secrets Manager - Store TLS Certificate (Public Certificate)
*/
resource "aws_secretsmanager_secret" "vault_tls_certificate" {
  name                    = "vault-tls-certificate-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "TLS public certificate for Vault servers generated by Let's Encrypt"
  recovery_window_in_days = 7 # Minimum recovery window

  tags = {
    Name        = "vault-tls-certificate"
    Environment = var.environment
    Purpose     = "vault-enterprise-tls-cert"
    Region      = var.region
  }
}

resource "aws_secretsmanager_secret_version" "vault_tls_certificate" {
  secret_id = aws_secretsmanager_secret.vault_tls_certificate.id
  secret_string = jsonencode({
    certificate = local.vault_cert # Public certificate (PEM format)
    domain      = local.domain
    created_at  = timestamp()
  })

  depends_on = [acme_certificate.certificate]
}

/*
AWS Secrets Manager - Store TLS Private Key
*/
resource "aws_secretsmanager_secret" "vault_tls_private_key" {
  name                    = "vault-tls-private-key-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "TLS private key for Vault servers generated by Let's Encrypt"
  recovery_window_in_days = 7 # Minimum recovery window

  tags = {
    Name        = "vault-tls-private-key"
    Environment = var.environment
    Purpose     = "vault-enterprise-tls-key"
    Region      = var.region
  }
}

resource "aws_secretsmanager_secret_version" "vault_tls_private_key" {
  secret_id = aws_secretsmanager_secret.vault_tls_private_key.id
  secret_string = jsonencode({
    private_key = local.vault_key # Private key (PEM format)
    domain      = local.domain
    created_at  = timestamp()
  })

  depends_on = [acme_certificate.certificate]
}

/*
AWS Secrets Manager - Store TLS CA Certificate
*/
resource "aws_secretsmanager_secret" "vault_tls_ca_certificate" {
  name                    = "vault-tls-ca-certificate-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "TLS CA certificate chain for Vault servers generated by Let's Encrypt"
  recovery_window_in_days = 7 # Minimum recovery window

  tags = {
    Name        = "vault-tls-ca-certificate"
    Environment = var.environment
    Purpose     = "vault-enterprise-tls-ca"
    Region      = var.region
  }
}

resource "aws_secretsmanager_secret_version" "vault_tls_ca_certificate" {
  secret_id = aws_secretsmanager_secret.vault_tls_ca_certificate.id
  secret_string = jsonencode({
    ca_certificate = local.vault_ca # CA certificate chain (PEM format)
    domain         = local.domain
    created_at     = timestamp()
  })

  depends_on = [acme_certificate.certificate]
}

/*
AWS Secrets Manager - Store Vault Enterprise license
Vault license can be retrieved securely by EC2 instances
*/
resource "aws_secretsmanager_secret" "vault_license" {
  name                    = "vault-enterprise-license-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "HashiCorp Vault Enterprise license key"
  recovery_window_in_days = 7 # Minimum recovery window

  tags = {
    Name        = "vault-enterprise-license"
    Environment = var.environment
    Purpose     = "vault-enterprise-licensing"
    Region      = var.region
  }
}

resource "aws_secretsmanager_secret_version" "vault_license" {
  secret_id = aws_secretsmanager_secret.vault_license.id
  secret_string = jsonencode({
    license    = var.vault_server.license_key
    created_at = timestamp()
    expires_at = var.vault_license_expires # If you have license expiration info
  })
}

/*
===========================================
NOMAD SERVER CONFIGURATION
===========================================
*/

/*
Request Let's Encrypt certificate for Nomad using DNS challenge
*/
resource "acme_certificate" "nomad_certificate" {
  account_key_pem = acme_registration.registration.account_key_pem
  common_name     = "nomad-${local.region_sanitized}-${random_string.random_name.result}.${local.domain}"

  dns_challenge {
    provider = "route53"

    config = {
      AWS_REGION = var.region
    }
  }

  depends_on = [acme_registration.registration]
}

/*
Certificate data extraction for Nomad
ACME provider returns:
- certificate_pem: The server certificate
- issuer_pem: The CA chain (intermediate + root certificates)
- certificate_p12: Optional PKCS12 format
*/
locals {
  nomad_cert = try(acme_certificate.nomad_certificate.certificate_pem, "")
  nomad_ca   = try(acme_certificate.nomad_certificate.issuer_pem, "")
  nomad_key  = try(acme_certificate.nomad_certificate.private_key_pem, "")

  # Full certificate chain for ACM (server cert + CA chain)
  nomad_full_chain = "${local.nomad_cert}${local.nomad_ca}"
}

/*
Create DNS domain for Nomad server pointing to ALB
*/
resource "aws_route53_record" "nomad" {
  zone_id = data.aws_route53_zone.env_dns_zone.zone_id
  name    = "nomad-${local.region_sanitized}-${random_string.random_name.result}.${local.domain}"
  type    = "A"

  alias {
    name                   = aws_lb.nomad_alb.dns_name
    zone_id                = aws_lb.nomad_alb.zone_id
    evaluate_target_health = true
  }
}

/*
AWS Secrets Manager - Store Nomad TLS Certificate (Public Certificate)
*/
resource "aws_secretsmanager_secret" "nomad_tls_certificate" {
  name                    = "nomad-tls-certificate-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "TLS public certificate for Nomad servers generated by Let's Encrypt"
  recovery_window_in_days = 7

  tags = {
    Name        = "nomad-tls-certificate"
    Environment = var.environment
    Purpose     = "nomad-enterprise-tls-cert"
    Region      = var.region
  }
}

resource "aws_secretsmanager_secret_version" "nomad_tls_certificate" {
  secret_id = aws_secretsmanager_secret.nomad_tls_certificate.id
  secret_string = jsonencode({
    certificate = local.nomad_cert
    domain      = local.domain
    created_at  = timestamp()
  })

  depends_on = [acme_certificate.nomad_certificate]
}

/*
AWS Secrets Manager - Store Nomad TLS Private Key
*/
resource "aws_secretsmanager_secret" "nomad_tls_private_key" {
  name                    = "nomad-tls-private-key-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "TLS private key for Nomad servers generated by Let's Encrypt"
  recovery_window_in_days = 7

  tags = {
    Name        = "nomad-tls-private-key"
    Environment = var.environment
    Purpose     = "nomad-enterprise-tls-key"
    Region      = var.region
  }
}

resource "aws_secretsmanager_secret_version" "nomad_tls_private_key" {
  secret_id = aws_secretsmanager_secret.nomad_tls_private_key.id
  secret_string = jsonencode({
    private_key = local.nomad_key
    domain      = local.domain
    created_at  = timestamp()
  })

  depends_on = [acme_certificate.nomad_certificate]
}

/*
AWS Secrets Manager - Store Nomad TLS CA Certificate
*/
resource "aws_secretsmanager_secret" "nomad_tls_ca_certificate" {
  name                    = "nomad-tls-ca-certificate-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "TLS CA certificate chain for Nomad servers generated by Let's Encrypt"
  recovery_window_in_days = 7

  tags = {
    Name        = "nomad-tls-ca-certificate"
    Environment = var.environment
    Purpose     = "nomad-enterprise-tls-ca"
    Region      = var.region
  }
}

resource "aws_secretsmanager_secret_version" "nomad_tls_ca_certificate" {
  secret_id = aws_secretsmanager_secret.nomad_tls_ca_certificate.id
  secret_string = jsonencode({
    ca_certificate = local.nomad_ca
    domain         = local.domain
    created_at     = timestamp()
  })

  depends_on = [acme_certificate.nomad_certificate]
}

/*
AWS Secrets Manager - Store Nomad Enterprise license
*/
resource "aws_secretsmanager_secret" "nomad_license" {
  name                    = "nomad-enterprise-license-${local.region_sanitized}-${random_string.random_name.result}"
  description             = "HashiCorp Nomad Enterprise license key"
  recovery_window_in_days = 7

  tags = {
    Name        = "nomad-enterprise-license"
    Environment = var.environment
    Purpose     = "nomad-enterprise-licensing"
    Region      = var.region
  }
}

resource "aws_secretsmanager_secret_version" "nomad_license" {
  secret_id = aws_secretsmanager_secret.nomad_license.id
  secret_string = jsonencode({
    license    = var.nomad_server.license_key
    created_at = timestamp()
    expires_at = var.nomad_license_expires
  })
}
